# Licensed under a 3-clause BSD style license, see LICENSE.
from __future__ import annotations

import math

from hepunits import constants
from hepunits.units import coulomb, e_SI, electronvolt, joule, kelvin, m, mole, s

UNARY_OPERATORS = {"pos", "neg", "inv"}

BINARY_OPERATORS = {
    "add",
    "sub",
    "mul",
    "div",
    "mod",
    "lt",
    "gt",
    "lte",
    "gte",
    "eq",
    "neq",
    "and",
    "or",
    "xor",
    "pow",
    "lshift",
    "rshift",
    "multi_out",
}

COMMON_OPERATOR_SYMBOLS = {
    "pos": "+",
    "neg": "-",
    "add": "+",
    "sub": "-",
    "mul": "*",
    "div": "/",
    "mod": "%",
    "lt": "<",
    "gt": ">",
    "lte": "<=",
    "gte": ">=",
    "eq": "==",
    "neq": "!=",
    "pow": "**",
    "lshift": "<<",
    "rshift": ">>",
}

NUMEXPR_OPERATOR_SYMBOLS = {
    **COMMON_OPERATOR_SYMBOLS,
    "inv": "~",
    "and": "&",
    "or": "|",
    "xor": "^",
}

ROOT_OPERATOR_SYMBOLS = {
    **COMMON_OPERATOR_SYMBOLS,
    "inv": "!",
    "and": "&&",
    "or": "||",
    # xor is not supported since ^ is interpreted as a power operator
    "multi_out": ":",
}

PYTHON_OPERATOR_SYMBOLS = {**NUMEXPR_OPERATOR_SYMBOLS}

NAMESPACES = {"math", "numpy", "np", "scipy", "tmath"}

FUNCTIONS = {
    # Common functions
    "sqrt",
    "abs",
    "pow",
    "log",
    "log10",
    "exp",
    "sin",
    "cos",
    "tan",
    "arcsin",
    "arccos",
    "arctan",
    "arctan2",
    "sinh",
    "cosh",
    "tanh",
    "arcsinh",
    "arccosh",
    "arctanh",
    # Functions specific to NumExpr
    "log1p",
    "expm1",
    "where",
    "conj",
    "real",
    "imag",
    "complex",
    "contains",
    # Functions specific to ROOT
    # One argument
    "besseli0",
    "besseli1",
    "besselj0",
    "besselj1",
    "bessely0",
    "bessely1",
    "ceil",
    "ceilnint",
    "dilog",
    "erf",
    "erfc",
    "erfinverse",
    "erfcinverse",
    "even",
    "factorial",
    "floor",
    "floornint",
    "freq",
    "kolmogorovprob",
    "landaui",
    "lngamma",
    "log2",
    "nextprime",
    "normquantile",
    "odd",
    "struveh0",
    "struveh1",
    "struvel0",
    "struvel1",
    # Two arguments
    "besseli",
    "besselk",
    "beta",
    "binomial",
    "chisquarequantile",
    "ldexp",
    "permute",
    "poisson",
    "poissoni",
    "prob",
    "student",
    "studenti",
    # Three arguments
    "areequalabs",
    "areequalrel",
    "betacf",
    "betadist",
    "betadisti",
    "betaincomplete",
    "binomiali",
    "bubblehigh",
    "bubblelow",
    "fdist",
    "fdisti",
    "vavilov",
    "vavilovi",
    # 4+ arguments
    "rootscubic",
    "quantiles",
    # Array functions in ROOT
    "sum$",
    "min$",
    "max$",
    "length$",
    "minif$",
    "maxif$",
    "alt$",
}

FUNCTION_ALIASES = {
    "ln": "log",
    "asin": "arcsin",
    "acos": "arccos",
    "atan": "arctan",
    "atan2": "arctan2",
    "asinh": "arcsinh",
    "acosh": "arccosh",
    "atanh": "arctanh",
}

# https://numexpr.readthedocs.io/en/latest/user_guide.html#supported-functions
NUMEXPR_FUNCTIONS = {
    "sqrt": "sqrt",
    "abs": "abs",
    "pow": "",  # This one is a special case since it needs to be written with **
    "log": "log",
    "log10": "log10",
    "log1p": "log1p",
    "exp": "exp",
    "expm1": "expm1",
    "sin": "sin",
    "cos": "cos",
    "tan": "tan",
    "arcsin": "arcsin",
    "arccos": "arccos",
    "arctan": "arctan",
    "arctan2": "arctan2",
    "sinh": "sinh",
    "cosh": "cosh",
    "tanh": "tanh",
    "arcsinh": "arcsinh",
    "arccosh": "arccosh",
    "arctanh": "arctanh",
    "where": "where",
    "conj": "conj",
    "real": "real",
    "imag": "imag",
    "complex": "complex",
    "contains": "contains",
}

# https://root.cern.ch/doc/master/namespaceTMath.html
ROOT_FUNCTIONS = {
    "sqrt": "TMath::Sqrt",
    "abs": "TMath::Abs",
    "pow": "TMath::Power",
    "log": "TMath::Log",
    "log2": "TMath::Log2",
    "log10": "TMath::Log10",
    "exp": "TMath::Exp",
    "sin": "TMath::Sin",
    "cos": "TMath::Cos",
    "tan": "TMath::Tan",
    "arcsin": "TMath::ASin",
    "arccos": "TMath::ACos",
    "arctan": "TMath::ATan",
    "arctan2": "TMath::ATan2",
    "sinh": "TMath::SinH",
    "cosh": "TMath::CosH",
    "tanh": "TMath::TanH",
    "arcsinh": "TMath::ASinH",
    "arccosh": "TMath::ACosH",
    "arctanh": "TMath::ATanH",
    # One argument
    "besseli0": "TMath::BesselI0",
    "besseli1": "TMath::BesselI1",
    "besselj0": "TMath::BesselJ0",
    "besselj1": "TMath::BesselJ1",
    "bessely0": "TMath::BesselY0",
    "bessely1": "TMath::BesselY1",
    "ceil": "TMath::Ceil",
    "ceilnint": "TMath::CeilNint",
    "dilog": "TMath::DiLog",
    "erf": "TMath::Erf",
    "erfc": "TMath::Erfc",
    "erfinverse": "TMath::ErfInverse",
    "erfcinverse": "TMath::ErfcInverse",
    "even": "TMath::Even",
    "factorial": "TMath::Factorial",
    "floor": "TMath::Floor",
    "floornint": "TMath::FloorNint",
    "freq": "TMath::Freq",
    "kolmogorovprob": "TMath::KolmogorovProb",
    "landaui": "TMath::LandauI",
    "lngamma": "TMath::LnGamma",
    "nextprime": "TMath::NextPrime",
    "normquantile": "TMath::NormQuantile",
    "odd": "TMath::Odd",
    "struveh0": "TMath::StruveH",
    "struveh1": "TMath::StruveH",
    "struvel0": "TMath::StruveL",
    "struvel1": "TMath::StruveL",
    # Two arguments
    "besseli": "TMath::BesselI",
    "besselk": "TMath::BesselK",
    "beta": "TMath::Beta",
    "binomial": "TMath::Binomial",
    "chisquarequantile": "TMath::ChisquareQuantile",
    "ldexp": "TMath::Ldexp",
    "permute": "TMath::Permute",
    "poisson": "TMath::Poisson",
    "poissoni": "TMath::PoissonI",
    "prob": "TMath::Prob",
    "student": "TMath::Student",
    "studenti": "TMath::StudentI",
    # Three arguments
    "areequalabs": "TMath::AreEqualAbs",
    "areequalrel": "TMath::AreEqualRel",
    "betacf": "TMath::BetaCf",
    "betadist": "TMath::BetaDist",
    "betadisti": "TMath::BetaDistI",
    "betaincomplete": "TMath::BetaIncomplete",
    "binomiali": "TMath::BinomialI",
    "bubblehigh": "TMath::BubbleHigh",
    "bubblelow": "TMath::BubbleLow",
    "fdist": "TMath::FDist",
    "fdisti": "TMath::FDistI",
    "vavilov": "TMath::Vavilov",
    "vavilovi": "TMath::VavilovI",
    # 4+ arguments
    "rootscubic": "TMath::RootsCubic",
    "quantiles": "TMath::Quantiles",
    # Array functions in ROOT
    "sum$": "Sum$",
    "min$": "Min$",
    "max$": "Max$",
    "length$": "Length$",
    "minif$": "MinIf$",
    "maxif$": "MaxIf$",
    "alt$": "Alt$",
}

PYTHON_FUNCTIONS = {
    "sqrt": "sqrt",
    "abs": "abs",
    "pow": "",  # This one is a special case since it needs to be written with **
    "log": "log",
    "log10": "log10",
    "log1p": "log1p",
    "exp": "exp",
    "expm1": "expm1",
    "sin": "sin",
    "cos": "cos",
    "tan": "tan",
    "arcsin": "arcsin",
    "arccos": "arccos",
    "arctan": "arctan",
    "arctan2": "arctan2",
    "sinh": "sinh",
    "cosh": "cosh",
    "tanh": "tanh",
    "arcsinh": "arcsinh",
    "arccosh": "arccosh",
    "arctanh": "arctanh",
    "where": "where",
    "conj": "conj",
    "real": "real",
    "imag": "imag",
    "complex": "complex",
    "contains": "contains",
}

CONSTANTS = {
    "true",
    "false",
    "inf",
    "neginf",
    "nan",
    "sqrt2",
    "e",
    "pi",
    "invpi",
    "piover2",
    "piover4",
    "tau",
    "ln10",
    "log10e",
    "deg2rad",
    "rad2deg",
    "avogadro",
    "k_boltzmann",
    "c_light",
    "eminus",
    "eplus",
    "h_planck",
    "hbar",
    "hbarc",
    "iteration",  # ROOT keyword
}

CONSTANTS_ALIASES = {
    "oneoverpi": "invpi",
    "twopi": "tau",
    "e_plus": "eplus",
    "e_minus": "eminus",
    "kboltzmann": "k_boltzmann",
    "clight": "c_light",
    "hplanck": "h_planck",
    "h_bar": "hbar",
    "h_bar_c": "hbarc",
}

NUMEXPR_CONSTANTS = {
    "true": True,
    "false": False,
    # inf, neginf, nan not supported
    "sqrt2": math.sqrt(2),
    "e": math.e,
    "pi": math.pi,
    "invpi": 1 / math.pi,
    "piover2": math.pi / 2,
    "piover4": math.pi / 4,
    "tau": 2 * math.pi,
    "ln10": math.log(10),
    "log10e": math.log10(math.e),
    "deg2rad": math.pi / 180,
    "rad2deg": 180 / math.pi,
    "avogadro": constants.Avogadro / (1 / mole),
    "k_boltzmann": constants.k_Boltzmann / (joule / kelvin),
    "c_light": constants.c_light / (m / s),
    "eminus": constants.eminus / (coulomb),
    "eplus": -constants.eminus / (coulomb),
    "h_planck": constants.h_Planck / (electronvolt * s / e_SI),
    "hbar": constants.hbar / (electronvolt * s / e_SI),
    "hbarc": constants.hbarc / (electronvolt * m / e_SI),
}

ROOT_CONSTANTS = {
    "true": "true",
    "false": "false",
    "inf": "TMath::Infinity()",
    "neginf": "-TMath::Infinity()",
    "nan": "TMath::QuietNaN()",
    "sqrt2": "TMath::Sqrt2()",
    "e": "TMath::E()",
    "pi": "TMath::Pi()",
    "invpi": "TMath::InvPi()",
    "piover2": "TMath::PiOver2()",
    "piover4": "TMath::PiOver4()",
    "tau": "TMath::TwoPi()",
    "ln10": "TMath::Ln10()",
    "log10e": "TMath::LogE()",
    "deg2rad": "TMath::DegToRad()",
    "rad2deg": "TMath::RadToDeg()",
    "avogadro": "TMath::Na()",
    "k_boltzmann": "TMath::K()",
    "c_light": "TMath::C()",
    "eminus": "-TMath::Qe()",
    "eplus": "TMath::Qe()",
    "h_planck": "TMath::H()",
    "hbar": "TMath::Hbar()",
    "hbarc": "(TMath::Hbar() * TMath::C())",
    "iteration": "iteration$",
}

PYTHON_CONSTANTS = {
    **NUMEXPR_OPERATOR_SYMBOLS,
    "inf": "float('inf')",
    "neginf": "float('-inf')",
    "nan": "float('nan')",
}
